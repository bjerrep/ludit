<!doctype html>
<html lang="en">

<head>

<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="icon" type="image/png" href="ludit.png" />

<script type="text/javascript" src="smoothie.js"></script>


<h1>Ludit</h1>

<link href="hurkanSwitch/style.css" rel="stylesheet">

<link rel="stylesheet" href="jquery-treetable-3.2.0/css/screen.css" media="screen" />
<link rel="stylesheet" href="jquery-treetable-3.2.0/css/jquery.treetable.css" />
<link rel="stylesheet" href="jquery-treetable-3.2.0/css/jquery.treetable.theme.default.css" />
<link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
<link rel='stylesheet' id='edd-styles-css'  href='style.css' type='text/css' media='all' />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">
<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Nunito:200,400,700'>

<style>
    input[type=checkbox]
    {
      /* Double-sized Checkboxes */
      -ms-transform: scale(2); /* IE */
      -moz-transform: scale(2); /* FF */
      -webkit-transform: scale(2); /* Safari and Chrome */
      -o-transform: scale(2); /* Opera */
      padding: 10px;
      margin-top: 25px;
    }

    input[type="radio"] {
        margin-left:20px;
    }

    .fieldset1
    {
        border:2px solid green;
        -moz-border-radius:8px;
        -webkit-border-radius:8px;
        border-radius:8px;
    }
	</style>

</head>

<body>
<div class="tabs">
    <nav class="tab-list">
        <a class="tab active" href="#one">Rooms</a>
        <a class="tab" href="#two">Setup</a>
        <a class="tab" href="#three">System</a>
        <a class="tab" href="#four">Twitse</a>
    </nav>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <div id="one" class="tab-content show">
        <div class="page1" id="page1"></div>
    </div>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <div id="two" class="tab-content">
        <div class="page2" id="page2"></div>

        <p>
           <input type="button" value="Save" onclick="SaveCurrentConfiguration();" >
        </p>
    </div>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <div id="three" class="tab-content">
        <h2>System status</h2>
        <table id="table_metrics">
            <caption>Monitor metrics</caption>
            <thead>
            <tr>
                <th>Metric</th>
                <th>Value</th>
            </tr>
            </thead>
        </table>

        <h2>Commands</h2>
        <div class="m_setting_container"><div class="m_setting_area"><div class="m_setting_section"><div class="m_settings_item"><div class="m_settings_row"><div class="m_settings_table">
            <div class="m_settings_cell">
                <input id="restart_all" name="restart_all" type="submit" value="Restart All"/>
                <input id="restart_ludit" name="restart_ludit" type="submit" value="Restart Ludit"/>
                <input id="reboot" name="reboot" type="submit" value="Reboot"/>
            </div>
        </div></div></div></div></div></div>

    </div>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <div id="four" class="tab-content">

        <h2>Twitse</h2>
        <div id="current_offsets_chart_timespan"></div>
        <canvas id="current_offsets_chart_element" style="width:100%; height:200px"></canvas>

        <h3>Device list:</h3>
        <canvas id="channel_box" width="500" height="150"></canvas>

        <h3>Max delta offset:</h3>
        <div id="max_offsets_chart_timespan"></div>
        <canvas id="max_offsets_chart_element" style="width:100%; height:200px"></canvas>

        <p>
            <input type="button" value="6 Hours" onclick="ButtonHours(6);" >
            <input type="button" value="Day" onclick="ButtonHours(24);" >
            <input type="button" value="Week" onclick="ButtonHours(24*7);" >
        </p>
        <div id="max_delta_mean"></div>

        <h3>Commands:</h3>
        <p>
            <input type="button" value="50us step response" onclick="CommandTransientTest();" >
        </p>


        <div id="wall_offset"></div>
        <div id="error"></div>
    </div>

</div>


<!-- - - - - - - - - javascript - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<script src="jquery-3.3.1.min.js"></script>
<script src="btnSwitch/jquery.btnswitch.js"></script>
<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
<script src="jquery.ui.touch-punch.min.js"></script>
<script src="js.js"></script>
<script src="jquery-treetable-3.2.0/jquery.treetable.js"></script>
<script src="hurkanSwitch/hurkanSwitch.js"></script>


<script>
$("#table_metrics").treetable({ expandable: true });
</script>


<script type="text/javascript">
    var ludit_saved_configuration = null;
    var ludit_unsaved_configuration = null;
    var channels = {};
    var colors = ['orange', 'yellow', 'white', 'blue', 'purple'];
    var offsets = {}
    var next_color = 0;
    var ms_per_pixel = 2000;
    var hours = 24;
    var no_configuration_reload = false;

    var smoothie_chart_max_delta = null;
    var max_delta_time_series = null;
    var _max_delta_chart = null;

    // https://stackoverflow.com/a/41818235
    try {
        var ludit_setup = JSON.parse($.getJSON({'url': "ludit_local.json", 'async': false}).responseText);
        console.log('connecting to ludit ws address ' + ludit_setup["ludit"]["address"])
    }
    catch(err) {
       alert("Missing file: 'ludit_local.json' not found. Make a local copy of 'ludit_local.json.template'");
    }

    class ChannelInfo {
        constructor(name, timeseries, color) {
            this._name = name;
            this._timeseries = timeseries;
            this._status = "online";
            this._color = color;
            this._lockstate = "unknown";
            this._loss = 0.0;
            this._meanabsdev = 0.0;
            this._rms = 0.0;
        }

        get timeseries() { return this._timeseries; }
        get status() { return this._status; }
        set status(new_status) { this._status = new_status; }
        get color() { return this._color; }
        set lockstate(new_lockstate) { this._lockstate = new_lockstate; }
        get lockstate() { return this._lockstate; }
        set loss(new_loss) { this._loss = new_loss; }
        get loss() { return this._loss; }
        set meanabsdev(new_meanabsdev) { this._meanabsdev = new_meanabsdev; }
        get meanabsdev() { return this._meanabsdev; }
        set rms(new_rms) { this._rms = new_rms; }
        get rms() { return this._rms; }
    };

    function update_channel_list() {
        var c = document.getElementById('channel_box').getContext('2d');
        var x1 = 10, x2 = 60, x3 = 110, x4 = 180, x5 = 230, x6 = 275, x7 = 310, xlast = x7;
        var y0 = 30, y = 50;
        var lineheight = 20;

        c.fillStyle = "dimgrey";
        c.fillRect(0, 0, xlast + 100, 150);
        c.font = 'bold 11px Arial, sans-serif';

        c.fillStyle = "black";
        c.fillText("Loss%", x4, y0);
        c.fillText("Offset", x5, y0);
        c.fillText("AMA", x6, y0);
        c.fillText("RMS", x7, y0);

        var keys = Object.keys(channels);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var channel_info = channels[key];
            c.fillStyle = channel_info.color;
            var yoff = y + (i * lineheight);
            c.fillText(key, x1, yoff);
            c.fillText(channel_info.status, x2, yoff);
            c.fillText(channel_info.lockstate, x3, yoff);
            c.fillText(parseFloat(channel_info.loss).toFixed(1), x4, yoff);
            var offset = offsets[key];
            if (offset != 'undefined') {
                c.fillText(parseFloat(offset).toFixed(1), x5, yoff);
            }
            c.fillText(parseFloat(channel_info.meanabsdev).toFixed(1), x6, yoff);
            c.fillText(parseFloat(channel_info.rms).toFixed(1), x7, yoff);
        }
    }

    function print_responsives() {
        var chart = document.getElementById("current_offsets_chart_element");
        var graph_width = chart.clientWidth;
        var minuttes = ms_per_pixel * graph_width / 60000.0;
        $("#current_offsets_chart_timespan").text("Timespan : " + minuttes.toFixed(1) + " min");
    }

    print_responsives();

    // -------------------------------------------

    var smoothie_chart = new SmoothieChart({
        responsive: true, millisPerPixel: ms_per_pixel,
        interpolation: 'bezier',
        maxValue: 100, minValue: -100,
        grid: { verticalSections: 10,}
    });

    var chart = document.getElementById("current_offsets_chart_element");
    smoothie_chart.streamTo(chart);

    smoothie_chart_max_delta = new SmoothieChart({
        responsive: true, enableDpiScaling: false, limitFPS: 1, scaleSmoothing: 1, nonRealtimeData: false,
        interpolation: 'bezier',
        maxValue: 100, minValue: 0,
        grid: { verticalSections: 10 }
    });

    _max_delta_chart = document.getElementById("max_offsets_chart_element");
    smoothie_chart_max_delta.options.millisPerPixel = 200000;
    smoothie_chart_max_delta.streamTo(_max_delta_chart);
    max_delta_time_series = new TimeSeries();
    smoothie_chart_max_delta.addTimeSeries(
        max_delta_time_series,
        { strokeStyle: "orange", fillStyle: "orange", lineWidth: 1 });
    max_delta_time_series.append(0, 0);

    // -------------------------------------------

    update_channel_list();

    ws_twitse = null;

    function start_twitse(url) {

        if (window["WebSocket"]) {
            next_color = 0;
            ws_twitse = new WebSocket(url);

            ws_twitse.onmessage = function (e) {
                var obj = JSON.parse(e.data);
                var command = obj['command'];

                if (command === "walloffset") {
                    $("#wall_offset").text("NTP wall offset : " + obj['value'] + " secs");
                    return;
                }

                if (command === "max_delta_offset_history") {
                    var time = JSON.parse(obj['time']);
                    var value = JSON.parse(obj['value']);
                    max_delta_time_series.clear();
                    for(var i=0; i < time.length; i++) {
                        max_delta_time_series.append(time[i], value[i]);
                    }
                    $("#max_delta_mean").text("Max delta: average = " + obj['mean_us'].toFixed(1) + " us, peak = " + obj['peak_us'].toFixed(1) + " us");
                }
                else if (command === "max_delta_offset") {
                    max_delta_time_series.append(obj['time'], obj['value']);
                    $("#max_delta_mean").text("Max delta: average = " + obj['mean_us'].toFixed(1) + " us, peak = " + obj['peak_us'].toFixed(1) + " us");
                }
                else {
                    var name = obj['name'];
                    var channel_info = channels[name];

                    if (channel_info === undefined) {
                        var time_series = new TimeSeries();
                        var color = colors[next_color++ % 6];
                        smoothie_chart.addTimeSeries(time_series, { strokeStyle: color, lineWidth: 3 });
                        channel_info = new ChannelInfo(name, time_series, color);
                        channel_info.status = "online";
                        channels[name] = channel_info;
                    }

                    if (command === "lockstateupdate") {
                        channel_info.lockstate = obj['lockstate']
                    }
                    else if (command === "connection_info") {
                        channel_info.loss = obj['loss']
                    }
                    else if (command === "current_offset") {
                        var time = obj['time'];
                        var value = obj['value'];

                        var time_series = channel_info.timeseries;
                        time_series.append(parseInt(time), parseFloat(value));

                        offsets[name] = value;
                        channel_info.meanabsdev = obj['meanabsdev']
                        channel_info.rms = obj['rms']
                        update_channel_list();
                    }
                }
            };
            ws_twitse.onclose = function (e) {
                channels = {};
                update_channel_list();
                ws_twitse = null;
            };
            ws_twitse.onopen = function (e) {
                console.log('twitse websocket connected');
                twitse_send({"command": "get_history"});

            };
        } else {
            $("#error").text("WebSocket init failed")
        }
    }

    ws_ludit = null;

    function start_ludit(url) {
        if (window["WebSocket"]) {
            ws_ludit = new WebSocket(url);
            ws_ludit.onmessage = function (e) {
                var obj = JSON.parse(e.data);
                var command = obj['command'];
                if (command == "configuration" && !no_configuration_reload) {
                    ludit_saved_configuration = obj['current_conf'];
                    reload_configuration();
                }
            };
            ws_ludit.onclose = function (e) {
                ws_ludit = null;
            };
            ws_ludit.onopen = function (e) {
                console.log("ludit websocket connected");
                ludit_send({"command": "get_configuration"});
            };
        } else {
            $("#error").text("WebSocket init failed")
        }
    }

    ws_monitor = null;

    function start_monitor(url) {
        if (window["WebSocket"]) {
            ws_monitor = new WebSocket(url);
            ws_monitor.onmessage = function (e) {
                var obj = JSON.parse(e.data);
                var command = obj['command'];
                var from = obj['from'];
                var result = obj['result'];
                if (command == "get_cputemperature")
                    add_metric('temperature', 'cputemperature', from, result);
                else if (command == "get_uptime")
                    add_metric('computers', 'uptime', from, result);
                else if (command == "get_loadaverages")
                    add_metric('computers', 'loadaverages', from, result);
                else if (command == "get_cpuload")
                    add_metric('computers', 'cpuload', from, result);
                else if (command == "get_ip")
                    add_metric('network', 'ip', from, result);
                else if (command == "get_wifi_stats")
                    add_metric('network', 'wifi', from, result);
                else if (command == "get_bluetooth_clients") {
                    var metrics = JSON.parse(result); // cant handle multiple clients
                    add_metric('bluetooth', 'clients', 'name', metrics['name']);
                    add_metric('bluetooth', 'clients', 'address', metrics['address']);
                    add_metric('bluetooth', 'clients', 'rssi', metrics['rssi']);
                }
            };
            ws_monitor.onclose = function (e) {
                ws_monitor = null;
            };
            ws_monitor.onopen = function (e) {
                console.log("ludit monitor connected");
                monitor_metrics_refresh();
                monitor_send({"command": "get_ip", "group": "n/a"});
            };
        } else {
            $("#error").text("WebSocket init failed")
        }
    }

    var interval = 100;
    var index = 0;
    var metrics_timer = setInterval(monitor_metrics_refresh, interval);

    function monitor_metrics_refresh() {
        switch(index++) {
            case 0: monitor_send({"command": "get_cputemperature", "group": "n/a"}); return;
            case 1: monitor_send({"command": "get_loadaverages", "group": "n/a"}); return;
            case 2: monitor_send({"command": "get_cpuload", "group": "n/a"}); return;
            case 3: monitor_send({"command": "get_uptime", "group": "n/a"}); return;
            case 4: monitor_send({"command": "get_wifi_stats", "group": "n/a"}); return;
            case 5: twitse_send( {"command": "get_wall_offset"}); return;
            case 6: monitor_send({"command": "get_bluetooth_clients"}); return;
        }
        if (interval < 2000) {
            interval = 2000;
            clearInterval(metrics_timer);
            metrics_timer = setInterval(monitor_metrics_refresh, interval);
        }
        index = 0;
    }

    function check_websockets() {
        if (!ws_ludit) {
            start_ludit(ws_url(ludit_setup["ludit"]["address"], ludit_setup["ludit"]["port"]));
        }
        if (!ws_monitor) {
            start_monitor(ws_url(ludit_setup["monitor"]["address"], ludit_setup["monitor"]["port"]));
        }
        if (!ws_twitse) {
            start_twitse(ws_url(ludit_setup["twitse"]["address"], ludit_setup["twitse"]["port"]));
        }
    }
    setInterval(check_websockets, 10000);
    check_websockets();


    function ludit_send(dict) {
        if (!ws_ludit || ws_ludit.readyState != WebSocket.OPEN)
            return;
        var jsn = JSON.stringify(dict);
        setTimeout(ws_ludit.send(jsn), 0);
    }

    function monitor_send(dict) {
        if (!ws_monitor || ws_monitor.readyState != WebSocket.OPEN)
            return;
        var jsn = JSON.stringify(dict);
        ws_monitor.send(jsn);
    }

    function twitse_send(dict) {
        if (!ws_twitse || ws_twitse.readyState != WebSocket.OPEN)
            return;
        var jsn = JSON.stringify(dict);
        ws_twitse.send(jsn);
    }

    function CommandTransientTest() {
        twitse_send({"command": "transient_test", "group": "n/a"});
    }

    function start_max_delta_chart() {
        console.log('start_max_delta_chart');
        twitse_send( {"command": "get_max_delta_history"});
        ButtonHours(24);
    }

    function ButtonHours(_hours) {
        if (_hours == 7*24)
            $("#max_offsets_chart_timespan").text("Timespan : Week");
        else if (_hours == 24)
            $("#max_offsets_chart_timespan").text("Timespan : Day");
        else
            $("#max_offsets_chart_timespan").text("Timespan : " + _hours + " Hour(s)");
        hours = _hours

        if (window._max_delta_chart && window._max_delta_chart.clientWidth > 0) {
                    var _max_delta_chart = document.getElementById("max_offsets_chart_element");
                    var timespan_ms = 1000 * 60 * 60 * hours;
                    var ms_per_pix = timespan_ms / window._max_delta_chart.clientWidth;
                    smoothie_chart_max_delta.options.millisPerPixel = ms_per_pix;
        }
    }

    function SaveCurrentConfiguration() {
        ludit_send({"command": "save_current_configuration"});
    }

    // fails on android firefox
    var ro = new ResizeObserver( entries => {
            if (window._max_delta_chart && window._max_delta_chart.clientWidth > 0) {
            console.log('settimeout on start_max_delta_chart');
            start_max_delta_chart();
            }
        });

    ro.observe(max_offsets_chart_element);

    $(document).ready(function() {
        $("#restart_all").click(function() {
            monitor_send({"command": "restart_all"});
        });
        $("#restart_ludit").click(function() {
            monitor_send({"command": "restart_ludit"});
        });
        $("#reboot").click(function() {
            monitor_send({"command": "reboot"});
        });
    });

</script>

</body>
</html>
